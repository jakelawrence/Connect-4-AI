{"version":3,"sources":["components/node.jsx","components/board.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","row","isEmpty","isPlayer","isAI","isSelector","isWinningPiece","onClick","extraClassName","backGroundClass","winningClass","className","id","Component","CENTER_COLUMN","Math","floor","COLUMNS","Board","state","board","winnerColor","winner","gameOver","difficulty","selectedDifficulty","depth","easy","medium","hard","drawBoard","setState","updateDifficulty","resetBoard","ROWS","piece","newBoard","dropPiece","forWinPlayer","checkForWin","isWin","finalBoard","highlightWin","minimaxReturn","minimax","rowAI","getNextOpenRow","move","getNewBoard","forWinAI","changeDifficulty","map","rowIdx","key","node","nodeIdx","style","backgroundColor","handleClick","color","turn","best","score","Infinity","legalMoves","getValidDrops","forEach","boardCopy","JSON","parse","stringify","moveScore","min","random","item","length","max","alpha","beta","currentDepth","isTerminalBoard","evaluate","i","checkPlayer","r","c","window","evaluateWindow","ai_pieces","player_pieces","empty_pieces","validRows","push","validDrops","fourInARow","one","two","three","four","currentRow","createNode","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"4SAyCeA,G,6KArCH,IAAD,EAUHC,KAAKC,MARPC,EAFK,EAELA,IACAC,EAHK,EAGLA,IACAC,EAJK,EAILA,QACAC,EALK,EAKLA,SACAC,EANK,EAMLA,KACAC,EAPK,EAOLA,WACAC,EARK,EAQLA,eACAC,EATK,EASLA,QAEIC,EAAiBN,EACnB,cACAC,EACA,eACAC,EACA,WACAC,EACA,iBACA,GACEI,EAAkBJ,EACpB,oBACA,kBAEEK,EAAeJ,EAAiB,eAAiB,GACvD,OACE,yBAAKK,UAAS,UAAKF,IACjB,yBACEG,GAAE,gBAAWX,EAAX,YAAkBD,GACpBW,UAAS,gBAAWH,EAAX,YAA6BE,GACtCH,QAAS,kBAAMA,EAAQP,W,GA/Bda,cCMbC,G,MAAgBC,KAAKC,MAAMC,MAE3BC,E,4MACJC,MAAQ,CAENC,MAAO,GAGPC,YAAa,GACbC,OAAQ,IAERC,UAAU,EAEVC,WAAY,CAEVC,mBAAoB,OAGpBC,MAAO,EAGPC,KAAM,2BACNC,OAAQ,mBACRC,KAAM,qB,kEAKR,IAAMT,EAAQU,IACdhC,KAAKiC,SAAS,CAAEX,Y,mCAIhB,IAAMA,EAAQU,IACdhC,KAAKiC,SAAS,CAAEX,UAChBtB,KAAKiC,SAAS,CAAET,OAAQ,KACxBxB,KAAKiC,SAAS,CAAER,UAAU,M,uCAIXC,GACf,IAAIQ,EAAmBlC,KAAKqB,MAAMK,WAElC,OAAQA,GACN,IAAK,OACHQ,EAAiBP,mBAAqB,OACtCO,EAAiBL,KAAO,2BACxBK,EAAiBJ,OAAS,mBAC1BI,EAAiBH,KAAO,mBACxBG,EAAiBN,MAAQ,EACzB5B,KAAKmC,aACL,MACF,IAAK,SACHD,EAAiBP,mBAAqB,SACtCO,EAAiBL,KAAO,mBACxBK,EAAiBJ,OAAS,2BAC1BI,EAAiBH,KAAO,mBACxBG,EAAiBN,MAAQ,EACzB5B,KAAKmC,aACL,MACF,QACED,EAAiBP,mBAAqB,OACtCO,EAAiBL,KAAO,mBACxBK,EAAiBJ,OAAS,mBAC1BI,EAAiBH,KAAO,2BACxBG,EAAiBN,MAAQ,EACzB5B,KAAKmC,aAGTnC,KAAKiC,SAAS,CAAEP,WAAYQ,M,kCAIlBhC,GAEV,IAAKF,KAAKqB,MAAMI,UAEgC,IAA1CzB,KAAKqB,MAAMC,MAAMc,GAAUlC,GAAKmC,MAAa,CAE/C,IAAIC,EAAWC,EAAUvC,KAAKqB,MAAMC,MAAOpB,EAjFpC,GAkFPF,KAAKiC,SAAS,CAAEX,MAAOgB,IAEvB,IAAIE,EAAeC,EAAYzC,KAAKqB,MAAMC,MApFnC,GAqFP,GAAIkB,EAAaE,MAAO,CAEtB,IAAIC,EAAaC,EAAaJ,EAAcxC,KAAKqB,MAAMC,OAQvD,YANAtB,KAAKiC,SAAS,CACZX,MAAOqB,EACPnB,OAAQ,WACRD,YAAa,MACbE,UAAU,IAMd,IAAIoB,EAAgBC,EAClB9C,KAAKqB,MAAMC,MACXtB,KAAKqB,MAAMK,WAAWE,MACtB5B,KAAKqB,MAAMK,WAAWC,oBAGpBoB,EAAQC,EAAeH,EAAcI,KAAMjD,KAAKqB,MAAMC,OAE1D,GAAIyB,EAAQX,EAAU,CACpB,IAAIE,EAAWY,EACbH,EACAF,EAAcI,KACdjD,KAAKqB,MAAMC,MA9GZ,GAiHDtB,KAAKiC,SAAS,CAAEX,MAAOgB,IAEvB,IAAIa,EAAWV,EAAYzC,KAAKqB,MAAMC,MAnHrC,GAoHD,GAAI6B,EAAST,MAAO,CAElB,IAAIC,EAAaC,EAAaO,EAAUnD,KAAKqB,MAAMC,OAOnD,YANAtB,KAAKiC,SAAS,CACZX,MAAOqB,EACPnB,OAAQ,WACRD,YAAa,OACbE,UAAU,S,+BASZ,IAAD,OACCH,EAAUtB,KAAKqB,MAAfC,MAER,OACE,yBAAKT,UAAU,QACb,yBAAKA,UAAU,QACb,yBAAKA,UAAU,SAAf,gBACA,yBAAKA,UAAU,mBACb,yBACEJ,QAAS,kBAAM,EAAK2C,iBAAiB,SACrCvC,UAAWb,KAAKqB,MAAMK,WAAWG,MAFnC,QAMA,yBACEpB,QAAS,kBAAM,EAAK2C,iBAAiB,WACrCvC,UAAWb,KAAKqB,MAAMK,WAAWI,QAFnC,UAMA,yBACErB,QAAS,kBAAM,EAAK2C,iBAAiB,SACrCvC,UAAWb,KAAKqB,MAAMK,WAAWK,MAFnC,SAOF,yBAAKlB,UAAU,WACb,yBAAKA,UAAU,gBAAgBJ,QAAS,kBAAM,EAAK0B,eAAnD,cAKJ,yBAAKtB,UAAU,SACZS,EAAM+B,KAAI,SAAClD,EAAKmD,GACf,OACE,yBAAKzC,UAAU,WAAW0C,IAAKD,GAC5BnD,EAAIkD,KAAI,SAACG,EAAMC,GAAa,IAEzBtD,EAOEqD,EAPFrD,IACAD,EAMEsD,EANFtD,IACAE,EAKEoD,EALFpD,QACAC,EAIEmD,EAJFnD,SACAC,EAGEkD,EAHFlD,KACAC,EAEEiD,EAFFjD,WACAC,EACEgD,EADFhD,eAGF,OACE,kBAAC,EAAD,CACEkD,MAAO,CAAEC,gBAAiB,QAC1BJ,IAAKE,EACLvD,IAAKA,EACLC,IAAKA,EACLC,QAASA,EACTC,SAAUA,EACVC,KAAMA,EACNC,WAAYA,EACZC,eAAgBA,EAChBC,QAAS,SAACP,GAAD,OAAS,EAAK0D,YAAY1D,cAQjD,yBAAKwD,MAAO,CAAEG,MAAO7D,KAAKqB,MAAME,aAAeV,UAAU,QACpDb,KAAKqB,MAAMG,a,GArMJT,aA6MdwB,EAAY,SAACjB,EAAOpB,EAAK4D,GAC7B,IAAI3D,EAAM6C,EAAe9C,EAAKoB,GAC9B,GAAInB,EAAMiC,EAER,OADec,EAAY/C,EAAKD,EAAKoB,EAAOwC,IAQ1ChB,EAAU,SAACxB,EAAOM,EAAOF,GAC7B,IAAIqC,EAAO,CACTd,KAAM,KACNe,OAAQC,KAKNC,EAAaC,EAAc7C,GAiB/B,GAfA4C,EAAWE,SAAQ,SAAClE,GAElB,IAAImE,EAAYC,KAAKC,MAAMD,KAAKE,UAAUlD,IACtCgB,EAAWC,EAAU8B,EAAWnE,EAxO7B,GA0OHuE,EAAYC,EAAIpC,GAVV,IACD2B,IASkC,EAAGrC,EAAOF,GAEjD+C,EAAYV,EAAKC,QACnBD,EAAKC,MAAQS,EACbV,EAAKd,KAAO/C,MAMG,SAAfwB,IAA0BT,KAAKC,MAAsB,EAAhBD,KAAK0D,UAAe,CAC3D,IAAIC,EAAOV,EAAWjD,KAAKC,MAAMD,KAAK0D,SAAWT,EAAWW,SAC5Dd,EAAKd,KAAO2B,EAEd,OAAOb,GAIHe,EAAM,SAACxD,EAAOyD,EAAOC,EAAMC,EAAcrD,EAAOF,GAEpD,GAAIwD,EAAgB5D,IAAU2D,IAAiBrD,EAC7C,OAAOuD,EAAS7D,EAAOI,GAWvB,IAJA,IAAIsC,GAASC,IAETC,EAAaC,EAAc7C,GAEtB8D,EAAI,EAAGA,EAAIlB,EAAWW,OAAQO,IAAK,CAG1C,IAAIf,EAAYC,KAAKC,MAAMD,KAAKE,UAAUlD,IACtCgB,EAAWC,EAAU8B,EAAWH,EAAWkB,GA9Q1C,GA+QDX,EAAYC,EACdpC,EACAyC,EACAC,EACAC,EAAe,EACfrD,EACAF,GAMF,GAHAsC,EAAQ/C,KAAK6D,IAAId,EAAOS,IACxBM,EAAQ9D,KAAK6D,IAAIC,EAAOf,KAEXgB,EACX,OAAOD,EAIX,OAAOf,GAKLU,EAAM,SAACpD,EAAOyD,EAAOC,EAAMC,EAAcrD,EAAOF,GAGpD,GAAIwD,EAAgB5D,IAAU2D,IAAiBrD,EAC7C,OAAOuD,EAAS7D,EAAOI,GAYvB,IAJA,IAAIsC,EAAQC,IAERC,EAAaC,EAAc7C,GAEtB8D,EAAI,EAAGA,EAAIlB,EAAWW,OAAQO,IAAK,CAG1C,IAAIf,EAAYC,KAAKC,MAAMD,KAAKE,UAAUlD,IACtCgB,EAAWC,EAAU8B,EAAWH,EAAWkB,GA1TtC,GA2TLX,EAAYK,EACdxC,EACAyC,EACAC,EACAC,EAAe,EACfrD,EACAF,GAMF,GAHAsC,EAAQ/C,KAAKyD,IAAIV,EAAOS,GAGpBM,IAFJC,EAAO/D,KAAKyD,IAAIM,EAAMhB,IAGpB,OAAOgB,EAIX,OAAOhB,GAULmB,EAAW,SAAC7D,EAAOI,GACvB,IAAIsC,EAAQ,EAEZ,GAAIkB,EAAgB5D,GAAQ,CAC1B,IAAI+D,EAAc5C,EAAYnB,EA1VnB,GA6VT0C,EAFYvB,EAAYnB,EA1VnB,GA2VKoB,MACFuB,IACCoB,EAAY3C,OACZuB,IAED,MAEL,CACL,IAAK,IAAIqB,EAAI,EAAGA,EAAIlD,EAAUkD,IACU,IAAlChE,EAAMgE,GAAGtE,GAAeqB,QAC1B2B,GAAS,GAIb,IAAK,IAAIsB,EAAI,EAAGA,EAAIlD,EAAUkD,IAC5B,IAAK,IAAIC,EAAI,EAAGA,EAAIpE,EAAaoE,IAAK,CACpC,IAAIC,EAAS,CACXlE,EAAMgE,GAAGC,GACTjE,EAAMgE,GAAGC,EAAI,GACbjE,EAAMgE,GAAGC,EAAI,GACbjE,EAAMgE,GAAGC,EAAI,IAEfvB,GAASyB,EAAeD,EAAQ9D,GAIpC,IAAK,IAAI6D,EAAI,EAAGA,EAvXJ,EAuXiBA,IAC3B,IAAK,IAAID,EAAI,EAAGA,EAAIlD,EAAUkD,IAAK,CACjC,IAAIE,EAAS,CACXlE,EAAMgE,GAAGC,GACTjE,EAAMgE,EAAI,GAAGC,GACbjE,EAAMgE,EAAI,GAAGC,GACbjE,EAAMgE,EAAI,GAAGC,IAEfvB,GAASyB,EAAeD,EAAQ9D,GAKpC,IAAK,IAAI6D,EAAI,EAAGA,EAAIpE,EAAaoE,IAC/B,IAAK,IAAID,EAAI,EAAGA,EAAIlD,EAAUkD,IAAK,CACjC,IAAIE,EAAS,CACXlE,EAAMgE,GAAGC,GACTjE,EAAMgE,EAAI,GAAGC,EAAI,GACjBjE,EAAMgE,EAAI,GAAGC,EAAI,GACjBjE,EAAMgE,EAAI,GAAGC,EAAI,IAEnBvB,GAASyB,EAAeD,EAAQ9D,GAKpC,IAAK,IAAI6D,EAAI,EAAGA,EAAIpE,EAAaoE,IAC/B,IAAK,IAAID,EAAI,EAAGA,EAAIlD,EAAUkD,IAAK,CACjC,IAAIE,EAAS,CACXlE,EAAMgE,GAAGC,GACTjE,EAAMgE,EAAI,GAAGC,EAAI,GACjBjE,EAAMgE,EAAI,GAAGC,EAAI,GACjBjE,EAAMgE,EAAI,GAAGC,EAAI,IAEnBvB,GAASyB,EAAeD,EAAQ9D,IAKtC,OAAOsC,GAKHyB,EAAiB,SAACD,EAAQ9D,GAO9B,IANA,IAAIsC,EAAQ,EACR0B,EAAY,EACZC,EAAgB,EAChBC,EAAe,EAGVR,EAAI,EAAGA,EAAII,EAAOX,OAAQO,IACjC,OAAQI,EAAOJ,GAAG/C,OAChB,KA1aK,EA2aHqD,IACA,MACF,KA9aS,EA+aPC,IACA,MACF,QACEC,IAoCN,MA9BmB,SAAflE,IACoB,IAAlBiE,GAAwC,IAAjBC,EACzB5B,GAAS,EACkB,IAAlB2B,GAAwC,IAAjBC,IAChC5B,GAAS,IAKM,WAAftC,IACoB,IAAlBiE,GAAwC,IAAjBC,EACzB5B,GAAS,EACkB,IAAlB2B,GAAwC,IAAjBC,IAChC5B,GAAS,IAMM,SAAftC,IACgB,IAAdgE,GAAoC,IAAjBE,IACrB5B,GAAS,GAEW,IAAlB2B,EACF3B,GAAS,EACkB,IAAlB2B,GAAwC,IAAjBC,IAChC5B,GAAS,IAINA,GAGHG,EAAgB,SAAC7C,GAErB,IADA,IAAIuE,EAAY,GACPN,EAAI,EAAGA,EA5dF,EA4deA,IACM,IAA7BjE,EAAMc,GAAUmD,GAAGlD,OACrBwD,EAAUC,KAAKP,GAGnB,OAAOM,GAGHX,EAAkB,SAAC5D,GACvB,IAAIyE,EAAa5B,EAAc7C,GAC/B,SACEmB,EAAYnB,EAteD,GAsegBoB,QAC3BD,EAAYnB,EAteL,GAsegBoB,OACD,IAAtBqD,EAAWlB,SAQTpC,EAAc,SAACnB,EAAOwC,GAqB1B,IAnBA,IAAIkC,EAAa,CACftD,OAAO,EACPuD,IAAK,CACHX,EAAG,EACHC,EAAG,GAELW,IAAK,CACHZ,EAAG,EACHC,EAAG,GAELY,MAAO,CACLb,EAAG,EACHC,EAAG,GAELa,KAAM,CACJd,EAAG,EACHC,EAAG,IAGEA,EAAI,EAAGA,EAAIpE,EAAaoE,IAC/B,IAAK,IAAID,EAAI,EAAGA,EAAIlD,EAAUkD,IAC5B,GACEhE,EAAMgE,GAAGC,GAAGlD,QAAUyB,GACtBxC,EAAMgE,GAAGC,EAAI,GAAGlD,QAAUyB,GAC1BxC,EAAMgE,GAAGC,EAAI,GAAGlD,QAAUyB,GAC1BxC,EAAMgE,GAAGC,EAAI,GAAGlD,QAAUyB,EAW1B,OATAkC,EAAWC,IAAIX,EAAIA,EACnBU,EAAWC,IAAIV,EAAIA,EACnBS,EAAWE,IAAIZ,EAAIA,EACnBU,EAAWE,IAAIX,EAAIA,EAAI,EACvBS,EAAWG,MAAMb,EAAIA,EACrBU,EAAWG,MAAMZ,EAAIA,EAAI,EACzBS,EAAWI,KAAKd,EAAIA,EACpBU,EAAWI,KAAKb,EAAIA,EAAI,EACxBS,EAAWtD,OAAQ,EACZsD,EAKb,IAAK,IAAIT,EAAI,EAAGA,EA5hBF,EA4hBeA,IAC3B,IAAK,IAAID,EAAI,EAAGA,EAAIlD,EAAUkD,IAC5B,GACEhE,EAAMgE,GAAGC,GAAGlD,QAAUyB,GACtBxC,EAAMgE,EAAI,GAAGC,GAAGlD,QAAUyB,GAC1BxC,EAAMgE,EAAI,GAAGC,GAAGlD,QAAUyB,GAC1BxC,EAAMgE,EAAI,GAAGC,GAAGlD,QAAUyB,EAW1B,OATAkC,EAAWC,IAAIX,EAAIA,EACnBU,EAAWC,IAAIV,EAAIA,EACnBS,EAAWE,IAAIZ,EAAIA,EAAI,EACvBU,EAAWE,IAAIX,EAAIA,EACnBS,EAAWG,MAAMb,EAAIA,EAAI,EACzBU,EAAWG,MAAMZ,EAAIA,EACrBS,EAAWI,KAAKd,EAAIA,EAAI,EACxBU,EAAWI,KAAKb,EAAIA,EACpBS,EAAWtD,OAAQ,EACZsD,EAKb,IAAK,IAAIT,EAAI,EAAGA,EAAIpE,EAAaoE,IAC/B,IAAK,IAAID,EAAI,EAAGA,EAAIlD,EAAUkD,IAC5B,GACEhE,EAAMgE,GAAGC,GAAGlD,QAAUyB,GACtBxC,EAAMgE,EAAI,GAAGC,EAAI,GAAGlD,QAAUyB,GAC9BxC,EAAMgE,EAAI,GAAGC,EAAI,GAAGlD,QAAUyB,GAC9BxC,EAAMgE,EAAI,GAAGC,EAAI,GAAGlD,QAAUyB,EAW9B,OATAkC,EAAWC,IAAIX,EAAIA,EACnBU,EAAWC,IAAIV,EAAIA,EACnBS,EAAWE,IAAIZ,EAAIA,EAAI,EACvBU,EAAWE,IAAIX,EAAIA,EAAI,EACvBS,EAAWG,MAAMb,EAAIA,EAAI,EACzBU,EAAWG,MAAMZ,EAAIA,EAAI,EACzBS,EAAWI,KAAKd,EAAIA,EAAI,EACxBU,EAAWI,KAAKb,EAAIA,EAAI,EACxBS,EAAWtD,OAAQ,EACZsD,EAKb,IAAK,IAAIT,EAAI,EAAGA,EAAIpE,EAAaoE,IAC/B,IAAK,IAAID,EAAI,EAAGA,EAAIlD,EAAUkD,IAC5B,GACEhE,EAAMgE,GAAGC,GAAGlD,QAAUyB,GACtBxC,EAAMgE,EAAI,GAAGC,EAAI,GAAGlD,QAAUyB,GAC9BxC,EAAMgE,EAAI,GAAGC,EAAI,GAAGlD,QAAUyB,GAC9BxC,EAAMgE,EAAI,GAAGC,EAAI,GAAGlD,QAAUyB,EAW9B,OATAkC,EAAWC,IAAIX,EAAIA,EACnBU,EAAWC,IAAIV,EAAIA,EACnBS,EAAWE,IAAIZ,EAAIA,EAAI,EACvBU,EAAWE,IAAIX,EAAIA,EAAI,EACvBS,EAAWG,MAAMb,EAAIA,EAAI,EACzBU,EAAWG,MAAMZ,EAAIA,EAAI,EACzBS,EAAWI,KAAKd,EAAIA,EAAI,EACxBU,EAAWI,KAAKb,EAAIA,EAAI,EACxBS,EAAWtD,OAAQ,EACZsD,EAIb,OAAOA,GAGHpD,EAAe,SAACoD,EAAY1E,GAKhC,OAJAA,EAAM0E,EAAWC,IAAIX,GAAGU,EAAWC,IAAIV,GAAG/E,gBAAiB,EAC3Dc,EAAM0E,EAAWE,IAAIZ,GAAGU,EAAWE,IAAIX,GAAG/E,gBAAiB,EAC3Dc,EAAM0E,EAAWG,MAAMb,GAAGU,EAAWG,MAAMZ,GAAG/E,gBAAiB,EAC/Dc,EAAM0E,EAAWI,KAAKd,GAAGU,EAAWI,KAAKb,GAAG/E,gBAAiB,EACtDc,GAGH0B,EAAiB,SAAC9C,EAAKoB,GAC3B,IAAK,IAAInB,EAAM,EAAGA,EAAMiC,EAAUjC,IAChC,GAA8B,IAA1BmB,EAAMnB,GAAKD,GAAKmC,MAClB,OAAOlC,EAGX,OAAO8D,KAGHf,EAAc,SAAC/C,EAAKD,EAAKoB,EAAOwC,GASpC,OARAxC,EAAMnB,GAAKD,GAAKmC,MAAQyB,EAjnBX,IAknBTA,EACFxC,EAAMnB,GAAKD,GAAKG,UAAW,EAE3BiB,EAAMnB,GAAKD,GAAKI,MAAO,EAEzBgB,EAAMnB,GAAKD,GAAKE,SAAU,EAEnBkB,GAGHU,EAAY,WAEhB,IADA,IAAMV,EAAQ,GACLnB,EAAM,EAAGA,EAhoBP,EAgoBmBA,IAAO,CAEnC,IADA,IAAMkG,EAAa,GACVnG,EAAM,EAAGA,EAjoBN,EAioBqBA,IAC/BmG,EAAWP,KAAKQ,EAAWpG,EAAKC,EAAK,IAEvCmB,EAAMwE,KAAKO,GAEb,OAAO/E,GAGHgF,EAAa,SAACpG,EAAKC,EAAKkC,GAC5B,MAAO,CACLnC,MACAC,MACAkC,QACAjC,QAAiBgC,IAARjC,EACTE,UAAU,EACVC,MAAM,EACNC,WAAoB6B,IAARjC,EACZK,gBAAgB,IAILY,I,KC9oBAmF,MARf,WACE,OACE,yBAAK1F,UAAU,OACb,kBAAC,EAAD,QCGc2F,QACW,cAA7BhB,OAAOiB,SAASC,UAEe,UAA7BlB,OAAOiB,SAASC,UAEhBlB,OAAOiB,SAASC,SAASC,MACvB,2DCXNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDwHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.b4a1ff01.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport \"./node.css\";\n\nclass Node extends Component {\n  render() {\n    const {\n      col,\n      row,\n      isEmpty,\n      isPlayer,\n      isAI,\n      isSelector,\n      isWinningPiece,\n      onClick,\n    } = this.props;\n    const extraClassName = isEmpty\n      ? \"piece-empty\"\n      : isPlayer\n      ? \"piece-player\"\n      : isAI\n      ? \"piece-AI\"\n      : isSelector\n      ? \"piece-selector\"\n      : \"\";\n    const backGroundClass = isSelector\n      ? \"selectorBackgound\"\n      : \"pieceBackground\";\n\n    const winningClass = isWinningPiece ? \"winningPiece\" : \"\";\n    return (\n      <div className={`${backGroundClass}`}>\n        <div\n          id={`piece-${row}-${col}`}\n          className={`piece ${extraClassName} ${winningClass}`}\n          onClick={() => onClick(col)}\n        ></div>\n      </div>\n    );\n  }\n}\n\nexport default Node;\n","import React, { Component } from \"react\";\nimport Node from \"./node.jsx\";\n\nimport \"./board.css\";\n\nconst ROWS = 7;\nconst COLUMNS = 7;\nconst PLAYER = 1;\nconst AI = 2;\nconst CENTER_COLUMN = Math.floor(COLUMNS / 2);\n\nclass Board extends Component {\n  state = {\n    //init board\n    board: [],\n\n    //for winner message after game over\n    winnerColor: \"\",\n    winner: \" \",\n\n    gameOver: false,\n\n    difficulty: {\n      //difficulty of ai, default is easy\n      selectedDifficulty: \"easy\",\n\n      //depth for the minimax algorithm\n      depth: 1,\n\n      //css classes for buttons\n      easy: \"difficultyButtonSelected\",\n      medium: \"difficultyButton\",\n      hard: \"difficultyButton\",\n    },\n  };\n\n  componentDidMount() {\n    const board = drawBoard();\n    this.setState({ board });\n  }\n  //for pressing new game\n  resetBoard() {\n    const board = drawBoard();\n    this.setState({ board });\n    this.setState({ winner: \"\" });\n    this.setState({ gameOver: false });\n  }\n\n  //changes difficulty in scoring for minimax and the depth the alg travels as well\n  changeDifficulty(difficulty) {\n    let updateDifficulty = this.state.difficulty;\n\n    switch (difficulty) {\n      case \"easy\":\n        updateDifficulty.selectedDifficulty = \"easy\";\n        updateDifficulty.easy = \"difficultyButtonSelected\";\n        updateDifficulty.medium = \"difficultyButton\";\n        updateDifficulty.hard = \"difficultyButton\";\n        updateDifficulty.depth = 2;\n        this.resetBoard();\n        break;\n      case \"medium\":\n        updateDifficulty.selectedDifficulty = \"medium\";\n        updateDifficulty.easy = \"difficultyButton\";\n        updateDifficulty.medium = \"difficultyButtonSelected\";\n        updateDifficulty.hard = \"difficultyButton\";\n        updateDifficulty.depth = 3;\n        this.resetBoard();\n        break;\n      default:\n        updateDifficulty.selectedDifficulty = \"hard\";\n        updateDifficulty.easy = \"difficultyButton\";\n        updateDifficulty.medium = \"difficultyButton\";\n        updateDifficulty.hard = \"difficultyButtonSelected\";\n        updateDifficulty.depth = 5;\n        this.resetBoard();\n        break;\n    }\n    this.setState({ difficulty: updateDifficulty });\n  }\n\n  //when a piece has been clicked, execute\n  handleClick(col) {\n    //if the game is not over\n    if (!this.state.gameOver) {\n      //if the column is not completely full of game pieces\n      if (this.state.board[ROWS - 2][col].piece === 0) {\n        //drop the piece\n        let newBoard = dropPiece(this.state.board, col, PLAYER);\n        this.setState({ board: newBoard });\n        //check for a four in a row\n        let forWinPlayer = checkForWin(this.state.board, PLAYER);\n        if (forWinPlayer.isWin) {\n          //highlight the four in a row with css\n          let finalBoard = highlightWin(forWinPlayer, this.state.board);\n          //set the footer to say the winner\n          this.setState({\n            board: finalBoard,\n            winner: \"YOU WIN!\",\n            winnerColor: \"red\",\n            gameOver: true,\n          });\n          return;\n        }\n\n        //get the score and column returned by the minimax\n        let minimaxReturn = minimax(\n          this.state.board, //game board\n          this.state.difficulty.depth, //how many steps the minimax looks ahead\n          this.state.difficulty.selectedDifficulty //difficulty selected by user\n        );\n        // get the row that is corresponding to the column returned by minimax for the placement\n        let rowAI = getNextOpenRow(minimaxReturn.move, this.state.board);\n        //double check the row isnt full\n        if (rowAI < ROWS - 1) {\n          let newBoard = getNewBoard(\n            rowAI,\n            minimaxReturn.move,\n            this.state.board,\n            AI\n          );\n          this.setState({ board: newBoard });\n          //check for four in a row\n          let forWinAI = checkForWin(this.state.board, AI);\n          if (forWinAI.isWin) {\n            //highlight four in a row with css\n            let finalBoard = highlightWin(forWinAI, this.state.board);\n            this.setState({\n              board: finalBoard,\n              winner: \"AI WINS!\",\n              winnerColor: \"gold\",\n              gameOver: true,\n            });\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  render() {\n    const { board } = this.state;\n\n    return (\n      <div className=\"main\">\n        <div className=\"head\">\n          <div className=\"title\">CONNECT 4 AI</div>\n          <div className=\"difficultyGroup\">\n            <div\n              onClick={() => this.changeDifficulty(\"easy\")}\n              className={this.state.difficulty.easy}\n            >\n              Easy\n            </div>\n            <div\n              onClick={() => this.changeDifficulty(\"medium\")}\n              className={this.state.difficulty.medium}\n            >\n              Medium\n            </div>\n            <div\n              onClick={() => this.changeDifficulty(\"hard\")}\n              className={this.state.difficulty.hard}\n            >\n              Hard\n            </div>\n          </div>\n          <div className=\"newGame\">\n            <div className=\"newGameButton\" onClick={() => this.resetBoard()}>\n              New Game\n            </div>\n          </div>\n        </div>\n        <div className=\"board\">\n          {board.map((row, rowIdx) => {\n            return (\n              <div className=\"pieceRow\" key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const {\n                    row,\n                    col,\n                    isEmpty,\n                    isPlayer,\n                    isAI,\n                    isSelector,\n                    isWinningPiece,\n                  } = node;\n\n                  return (\n                    <Node\n                      style={{ backgroundColor: \"blue\" }}\n                      key={nodeIdx}\n                      col={col}\n                      row={row}\n                      isEmpty={isEmpty}\n                      isPlayer={isPlayer}\n                      isAI={isAI}\n                      isSelector={isSelector}\n                      isWinningPiece={isWinningPiece}\n                      onClick={(col) => this.handleClick(col)}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n        <div style={{ color: this.state.winnerColor }} className=\"foot\">\n            {this.state.winner}\n        </div>\n      </div>\n    );\n  }\n}\n\n//drop the piece in the game board\nconst dropPiece = (board, col, turn) => {\n  let row = getNextOpenRow(col, board);\n  if (row < ROWS - 1) {\n    let newBoard = getNewBoard(row, col, board, turn);\n    return newBoard;\n  }\n};\n\n//minimax algorithm searches all possibilites to a certain depth\n//uses alpha beta pruing to speed up the process\n//finds the most effective move based on heuristuc score\nconst minimax = (board, depth, difficulty) => {\n  let best = {\n    move: null,\n    score: -Infinity,\n  };\n  let alpha = -Infinity;\n  let beta = Infinity;\n  //get all non-filled rows\n  let legalMoves = getValidDrops(board);\n  //simulate drops for each row that is available\n  legalMoves.forEach((col) => {\n    //create a deep copy of board to avoid changing the state\n    let boardCopy = JSON.parse(JSON.stringify(board));\n    let newBoard = dropPiece(boardCopy, col, AI);\n    //pass to min\n    let moveScore = min(newBoard, alpha, beta, 1, depth, difficulty);\n    //find the best score of all the columns\n    if (moveScore > best.score) {\n      best.score = moveScore;\n      best.move = col;\n    }\n    if (alpha >= beta) {\n      return;\n    }\n  });\n  if (difficulty === \"easy\" && !Math.floor(Math.random() * 3)) {\n    let item = legalMoves[Math.floor(Math.random() * legalMoves.length)];\n    best.move = item;\n  }\n  return best;\n};\n\n//find the move that benefits the AI the most, which is the largest possible heuristic score\nconst max = (board, alpha, beta, currentDepth, depth, difficulty) => {\n  //if the move leads to a connect 4 or tie game\n  if (isTerminalBoard(board) || currentDepth === depth) {\n    return evaluate(board, difficulty);\n  }\n  //simulate all possible drops again\n  //this is a recursive functiom\n  //look up minimax pseudocode if confused\n  else {\n    //start with lowest possible score, negative infinity\n    let score = -Infinity;\n    //get all open columns\n    let legalMoves = getValidDrops(board);\n    //simulate a drop for each possible move\n    for (let i = 0; i < legalMoves.length; i++) {\n      //deep copy board so it doesn't change the current state\n      //we do this because we are just simulating the drops\n      let boardCopy = JSON.parse(JSON.stringify(board));\n      let newBoard = dropPiece(boardCopy, legalMoves[i], AI);\n      let moveScore = min(\n        newBoard,\n        alpha,\n        beta,\n        currentDepth + 1,\n        depth,\n        difficulty\n      );\n      //find the score that is best for AI and set it to the new best score\n      score = Math.max(score, moveScore);\n      alpha = Math.max(alpha, score);\n      //we use alpha beta pruing to break out of a simulated move\n      if (alpha >= beta) {\n        return alpha;\n      }\n    }\n\n    return score;\n  }\n};\n\n//find the move that hurts the PLAYER the most, which is the smallest possible heuristic score\nconst min = (board, alpha, beta, currentDepth, depth, difficulty) => {\n  //if the move leads to a connect 4 or tie game\n  //or if the minimax has looked as far as it can go with the given depth\n  if (isTerminalBoard(board) || currentDepth === depth) {\n    return evaluate(board, difficulty);\n  }\n\n  //simulate all possible drops again\n  //this is a recursive functiom\n  //look up minimax pseudocode if confused\n  else {\n    //start with highest possible score, infinity\n    let score = Infinity;\n    //get all open columns\n    let legalMoves = getValidDrops(board);\n    //simulate a drop for each possible move\n    for (let i = 0; i < legalMoves.length; i++) {\n      //deep copy board so it doesn't change the current state\n      //we do this because we are just simulating the drops\n      let boardCopy = JSON.parse(JSON.stringify(board));\n      let newBoard = dropPiece(boardCopy, legalMoves[i], PLAYER);\n      let moveScore = max(\n        newBoard,\n        alpha,\n        beta,\n        currentDepth + 1,\n        depth,\n        difficulty\n      );\n      //find the score that inhibits PLAYER the most and set it to the new best score\n      score = Math.min(score, moveScore);\n      beta = Math.min(beta, score);\n      //we use alpha beta pruing to break out of a simulated move\n      if (alpha >= beta) {\n        return beta;\n      }\n    }\n\n    return score;\n  }\n};\n\n//if the game has been simulated to its end by the minimac algorithm\n//check who has one the simulated game\n//if its the AI, we want that move so return infinity\n//if its the PLAYER, we dont want that move, so return negative infinity\n//else, the game is a tie so we return zero\n//if the game has been simulated to the maximum depth\nconst evaluate = (board, difficulty) => {\n  let score = 0;\n\n  if (isTerminalBoard(board)) {\n    let checkPlayer = checkForWin(board, PLAYER);\n    let checkAI = checkForWin(board, AI);\n    if (checkAI.isWin) {\n      score = Infinity;\n    } else if (checkPlayer.isWin) {\n      score = -Infinity;\n    } else {\n      score = 0;\n    }\n  } else {\n    for (let r = 0; r < ROWS - 1; r++) {\n      if (board[r][CENTER_COLUMN].piece === 2) {\n        score += 1;\n      }\n    }\n    //score horizontal opportunities\n    for (let r = 0; r < ROWS - 1; r++) {\n      for (let c = 0; c < COLUMNS - 3; c++) {\n        let window = [\n          board[r][c],\n          board[r][c + 1],\n          board[r][c + 2],\n          board[r][c + 3],\n        ];\n        score += evaluateWindow(window, difficulty);\n      }\n    }\n    //score vertical opportunities\n    for (let c = 0; c < COLUMNS; c++) {\n      for (let r = 0; r < ROWS - 4; r++) {\n        let window = [\n          board[r][c],\n          board[r + 1][c],\n          board[r + 2][c],\n          board[r + 3][c],\n        ];\n        score += evaluateWindow(window, difficulty);\n      }\n    }\n\n    //score upward diagonal opportunities\n    for (let c = 0; c < COLUMNS - 3; c++) {\n      for (let r = 0; r < ROWS - 4; r++) {\n        let window = [\n          board[r][c],\n          board[r + 1][c + 1],\n          board[r + 2][c + 2],\n          board[r + 3][c + 3],\n        ];\n        score += evaluateWindow(window, difficulty);\n      }\n    }\n\n    //score downward diagonal opportunites\n    for (let c = 0; c < COLUMNS - 3; c++) {\n      for (let r = 3; r < ROWS - 1; r++) {\n        let window = [\n          board[r][c],\n          board[r - 1][c + 1],\n          board[r - 2][c + 2],\n          board[r - 3][c + 3],\n        ];\n        score += evaluateWindow(window, difficulty);\n      }\n    }\n  }\n\n  return score;\n};\n\n//score the window given by evaluateNonEnd\n//this is where the difficulties come into play\nconst evaluateWindow = (window, difficulty) => {\n  let score = 0;\n  let ai_pieces = 0;\n  let player_pieces = 0;\n  let empty_pieces = 0;\n\n  //count the pieces in the given window of 4 pieces passed in\n  for (let i = 0; i < window.length; i++) {\n    switch (window[i].piece) {\n      case AI:\n        ai_pieces++;\n        break;\n      case PLAYER:\n        player_pieces++;\n        break;\n      default:\n        empty_pieces++;\n    }\n  }\n\n  //easy difficulty will still preven the player from getting 4 in a fours\n  //but it doesn't try to set itself up for any moves in the future for the most part\n  if (difficulty === \"easy\") {\n    if (player_pieces === 3 && empty_pieces === 1) {\n      score -= 1;\n    } else if (player_pieces === 2 && empty_pieces === 2) {\n      score -= 2;\n    }\n  }\n  //medium will still not set up for much in the future\n  //but the depth is greater so its harder to beat than the easy AI\n  if (difficulty === \"medium\") {\n    if (player_pieces === 3 && empty_pieces === 1) {\n      score -= 1;\n    } else if (player_pieces === 2 && empty_pieces === 2) {\n      score -= 2;\n    }\n  }\n  //the hard is looking farther into the game for the best moves\n  //it is also minimizing the win for the PLAYER\n  //while simultaneously maximizing the AIs change to win\n  if (difficulty === \"hard\") {\n    if (ai_pieces === 3 && empty_pieces === 1) {\n      score += 2;\n    }\n    if (player_pieces === 4) {\n      score -= 4;\n    } else if (player_pieces === 3 && empty_pieces === 1) {\n      score -= 2;\n    }\n  }\n\n  return score;\n};\n\nconst getValidDrops = (board) => {\n  let validRows = [];\n  for (let c = 0; c < COLUMNS; c++) {\n    if (board[ROWS - 2][c].piece === 0) {\n      validRows.push(c);\n    }\n  }\n  return validRows;\n};\n\nconst isTerminalBoard = (board) => {\n  let validDrops = getValidDrops(board);\n  if (\n    checkForWin(board, PLAYER).isWin ||\n    checkForWin(board, AI).isWin ||\n    validDrops.length === 0\n  ) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nconst checkForWin = (board, turn) => {\n  //check horizontal wins\n  let fourInARow = {\n    isWin: false,\n    one: {\n      r: 0,\n      c: 0,\n    },\n    two: {\n      r: 0,\n      c: 0,\n    },\n    three: {\n      r: 0,\n      c: 0,\n    },\n    four: {\n      r: 0,\n      c: 0,\n    },\n  };\n  for (let c = 0; c < COLUMNS - 3; c++) {\n    for (let r = 0; r < ROWS - 1; r++) {\n      if (\n        board[r][c].piece === turn &&\n        board[r][c + 1].piece === turn &&\n        board[r][c + 2].piece === turn &&\n        board[r][c + 3].piece === turn\n      ) {\n        fourInARow.one.r = r;\n        fourInARow.one.c = c;\n        fourInARow.two.r = r;\n        fourInARow.two.c = c + 1;\n        fourInARow.three.r = r;\n        fourInARow.three.c = c + 2;\n        fourInARow.four.r = r;\n        fourInARow.four.c = c + 3;\n        fourInARow.isWin = true;\n        return fourInARow;\n      }\n    }\n  }\n  //check vertical wins\n  for (let c = 0; c < COLUMNS; c++) {\n    for (let r = 0; r < ROWS - 4; r++) {\n      if (\n        board[r][c].piece === turn &&\n        board[r + 1][c].piece === turn &&\n        board[r + 2][c].piece === turn &&\n        board[r + 3][c].piece === turn\n      ) {\n        fourInARow.one.r = r;\n        fourInARow.one.c = c;\n        fourInARow.two.r = r + 1;\n        fourInARow.two.c = c;\n        fourInARow.three.r = r + 2;\n        fourInARow.three.c = c;\n        fourInARow.four.r = r + 3;\n        fourInARow.four.c = c;\n        fourInARow.isWin = true;\n        return fourInARow;\n      }\n    }\n  }\n  //check for upward diagonal wins\n  for (let c = 0; c < COLUMNS - 3; c++) {\n    for (let r = 0; r < ROWS - 4; r++) {\n      if (\n        board[r][c].piece === turn &&\n        board[r + 1][c + 1].piece === turn &&\n        board[r + 2][c + 2].piece === turn &&\n        board[r + 3][c + 3].piece === turn\n      ) {\n        fourInARow.one.r = r;\n        fourInARow.one.c = c;\n        fourInARow.two.r = r + 1;\n        fourInARow.two.c = c + 1;\n        fourInARow.three.r = r + 2;\n        fourInARow.three.c = c + 2;\n        fourInARow.four.r = r + 3;\n        fourInARow.four.c = c + 3;\n        fourInARow.isWin = true;\n        return fourInARow;\n      }\n    }\n  }\n  //check for downward diagonal wins\n  for (let c = 0; c < COLUMNS - 3; c++) {\n    for (let r = 3; r < ROWS - 1; r++) {\n      if (\n        board[r][c].piece === turn &&\n        board[r - 1][c + 1].piece === turn &&\n        board[r - 2][c + 2].piece === turn &&\n        board[r - 3][c + 3].piece === turn\n      ) {\n        fourInARow.one.r = r;\n        fourInARow.one.c = c;\n        fourInARow.two.r = r - 1;\n        fourInARow.two.c = c + 1;\n        fourInARow.three.r = r - 2;\n        fourInARow.three.c = c + 2;\n        fourInARow.four.r = r - 3;\n        fourInARow.four.c = c + 3;\n        fourInARow.isWin = true;\n        return fourInARow;\n      }\n    }\n  }\n  return fourInARow;\n};\n\nconst highlightWin = (fourInARow, board) => {\n  board[fourInARow.one.r][fourInARow.one.c].isWinningPiece = true;\n  board[fourInARow.two.r][fourInARow.two.c].isWinningPiece = true;\n  board[fourInARow.three.r][fourInARow.three.c].isWinningPiece = true;\n  board[fourInARow.four.r][fourInARow.four.c].isWinningPiece = true;\n  return board;\n};\n\nconst getNextOpenRow = (col, board) => {\n  for (let row = 0; row < ROWS - 1; row++) {\n    if (board[row][col].piece === 0) {\n      return row;\n    }\n  }\n  return Infinity;\n};\n\nconst getNewBoard = (row, col, board, turn) => {\n  board[row][col].piece = turn;\n  if (turn === PLAYER) {\n    board[row][col].isPlayer = true;\n  } else {\n    board[row][col].isAI = true;\n  }\n  board[row][col].isEmpty = false;\n\n  return board;\n};\n\nconst drawBoard = () => {\n  const board = [];\n  for (let row = 0; row < ROWS; row++) {\n    const currentRow = [];\n    for (let col = 0; col < COLUMNS; col++) {\n      currentRow.push(createNode(col, row, 0));\n    }\n    board.push(currentRow);\n  }\n  return board;\n};\n\nconst createNode = (col, row, piece) => {\n  return {\n    col,\n    row,\n    piece,\n    isEmpty: row !== ROWS - 1,\n    isPlayer: false,\n    isAI: false,\n    isSelector: row === ROWS - 1,\n    isWinningPiece: false,\n  };\n};\n\nexport default Board;\n","import React from \"react\";\n\nimport \"./App.css\";\nimport Board from \"./components/board\";\nimport \"bootstrap/dist/css/bootstrap.css\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Board></Board>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"bootstrap/dist/css/bootstrap.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}