{"version":3,"sources":["components/node.jsx","components/head.jsx","components/board.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","Component","this","props","col","row","isEmpty","isPlayer","isAI","isSelector","onClick","extraClassName","backGroundClass","className","id","CENTER_COLUMN","Math","floor","COLUMNS","Board","state","grid","nextOpenRow","gameInProgress","winner","drawBoard","setState","newGrid","dropPiece","checkForWin","console","log","minimaxReturn","minimax","rowAI","getNextOpenRow","move","ROWS","getNewGrid","map","rowIdx","key","node","nodeIdx","style","backgroundColor","handleClick","turn","best","score","Infinity","random","getValidDrops","forEach","gridCopy","JSON","parse","stringify","newBoard","moveScore","min","max","alpha","beta","currentDepth","isTerminalGrid","evaluateEnd","evaluateNonEnd","legalMoves","i","length","piece","r","c","window","evaluateWindow","ai_pieces","player_pieces","empty_pieces","validRows","push","validDrops","currentRow","createNode","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.5cf5447b.chunk.js","sourcesContent":["import React, { Component } from \"react\";\nimport \"./node.css\";\n\nclass Node extends Component {\n  render() {\n    const {\n      col,\n      row,\n      isEmpty,\n      isPlayer,\n      isAI,\n      isSelector,\n      onClick,\n    } = this.props;\n    const extraClassName = isEmpty\n      ? \"piece-empty\"\n      : isPlayer\n      ? \"piece-player\"\n      : isAI\n      ? \"piece-AI\"\n      : isSelector\n      ? \"piece-selector\"\n      : \"\";\n    const backGroundClass = isSelector\n      ? \"selectorBackgound\"\n      : \"pieceBackground\";\n    return (\n      <div className={`${backGroundClass}`}>\n        <div\n          id={`piece-${row}-${col}`}\n          className={`piece ${extraClassName}`}\n          onClick={() => onClick(col)}\n        ></div>\n      </div>\n    );\n  }\n}\n\nexport default Node;\n","import React, { Component } from \"react\";\n\nclass Head extends Component {\n  state = {};\n  render() {\n    return <h1>Hi</h1>;\n  }\n}\n\nexport default Head;\n","import React, { Component } from \"react\";\nimport Node from \"./node.jsx\";\n\nimport \"./board.css\";\n\nconst ROWS = 7;\nconst COLUMNS = 7;\nconst PLAYER = 1;\nconst AI = 2;\nconst DEPTH = 5;\nconst CENTER_COLUMN = Math.floor(COLUMNS / 2);\n\nclass Board extends Component {\n  state = {\n    grid: [],\n    nextOpenRow: [],\n    gameInProgress: true,\n    winner: 0,\n  };\n\n  componentDidMount() {\n    const grid = drawBoard();\n    this.setState({ grid });\n  }\n\n  handleClick(col) {\n    let newGrid = dropPiece(this.state.grid, col, PLAYER);\n    this.setState({ grid: newGrid });\n    if (checkForWin(this.state.grid, PLAYER)) {\n      console.log(\"PLAYER WINS\");\n    }\n    let minimaxReturn = minimax(this.state.grid);\n    console.log(minimaxReturn);\n    let rowAI = getNextOpenRow(minimaxReturn.move, this.state.grid);\n    if (rowAI < ROWS - 1) {\n      let newGrid = getNewGrid(rowAI, minimaxReturn.move, this.state.grid, AI);\n      this.setState({ grid: newGrid });\n      if (checkForWin(this.state.grid, AI)) {\n        console.log(\"AI WINS\");\n      }\n    }\n  }\n\n  render() {\n    const { grid } = this.state;\n    const { gameInProgress } = this.state;\n    return (\n      <div className=\"backdrop\">\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div className=\"row\" key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const {\n                    row,\n                    col,\n                    isEmpty,\n                    isPlayer,\n                    isAI,\n                    isSelector,\n                  } = node;\n\n                  return (\n                    <Node\n                      style={{ backgroundColor: \"blue\" }}\n                      key={nodeIdx}\n                      col={col}\n                      row={row}\n                      isEmpty={isEmpty}\n                      isPlayer={isPlayer}\n                      isAI={isAI}\n                      isSelector={isSelector}\n                      onClick={(col, grid) => this.handleClick(col)}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n\nconst dropPiece = (grid, col, turn) => {\n  let row = getNextOpenRow(col, grid);\n  if (row < ROWS - 1) {\n    let newGrid = getNewGrid(row, col, grid, turn);\n    return newGrid;\n  }\n};\n\nconst minimax = (grid) => {\n  let best = {\n    move: null,\n    score: -Infinity,\n  };\n  best.move = Math.floor(Math.random() * COLUMNS);\n  let alpha = -Infinity;\n  let beta = Infinity;\n  let legalMoves = getValidDrops(grid);\n  legalMoves.forEach((col) => {\n    let gridCopy = JSON.parse(JSON.stringify(grid));\n    let newBoard = dropPiece(gridCopy, col, AI);\n    let moveScore = min(newBoard, alpha, beta, 1);\n    if (moveScore > best.score) {\n      best.score = moveScore;\n      best.move = col;\n    }\n  });\n  return best;\n};\n\nconst max = (grid, alpha, beta, currentDepth) => {\n  if (isTerminalGrid(grid)) {\n    return evaluateEnd(grid);\n  } else if (currentDepth === DEPTH) {\n    return evaluateNonEnd(grid);\n  } else {\n    let score = -Infinity;\n    let legalMoves = getValidDrops(grid);\n\n    for (let i = 0; i < legalMoves.length; i++) {\n      let gridCopy = JSON.parse(JSON.stringify(grid));\n      let newBoard = dropPiece(gridCopy, legalMoves[i], AI);\n      let moveScore = min(newBoard, alpha, beta, currentDepth + 1);\n      if (moveScore > score) {\n        score = moveScore;\n      }\n      alpha = Math.max(alpha, score);\n      if (alpha >= beta) {\n        break;\n      }\n    }\n\n    return score;\n  }\n};\n\nconst min = (grid, alpha, beta, currentDepth) => {\n  if (isTerminalGrid(grid)) {\n    return evaluateEnd(grid);\n  } else if (currentDepth === DEPTH) {\n    return evaluateNonEnd(grid);\n  } else {\n    let score = Infinity;\n    let legalMoves = getValidDrops(grid);\n    for (let i = 0; i < legalMoves.length; i++) {\n      let gridCopy = JSON.parse(JSON.stringify(grid));\n      let newBoard = dropPiece(gridCopy, legalMoves[i], PLAYER);\n      let moveScore = max(newBoard, alpha, beta, currentDepth + 1);\n      if (moveScore < score) {\n        score = moveScore;\n      }\n      beta = Math.min(beta, score);\n      if (alpha >= beta) {\n        break;\n      }\n    }\n\n    return score;\n  }\n};\n\nconst evaluateEnd = (grid) => {\n  if (checkForWin(grid, AI) === true) {\n    return Infinity;\n  } else if (checkForWin(grid, PLAYER) === true) {\n    return -Infinity;\n  } else {\n    return 0;\n  }\n};\n\nconst evaluateNonEnd = (grid) => {\n  let score = 0;\n  //score center column, more opportunities with the center column\n  for (let row = 0; row < ROWS - 1; row++) {\n    if (grid[row][CENTER_COLUMN].piece === AI) {\n      score += 3;\n    }\n  }\n  //score horizontal opportunities\n  for (let r = 0; r < ROWS - 1; r++) {\n    for (let c = 0; c < COLUMNS - 3; c++) {\n      let window = [grid[r][c], grid[r][c + 1], grid[r][c + 2], grid[r][c + 3]];\n      score += evaluateWindow(window);\n    }\n  }\n  //score vertical opportunities\n  for (let c = 0; c < COLUMNS; c++) {\n    for (let r = 0; r < ROWS - 4; r++) {\n      let window = [grid[r][c], grid[r + 1][c], grid[r + 2][c], grid[r + 3][c]];\n      score += evaluateWindow(window);\n    }\n  }\n\n  for (let c = 0; c < COLUMNS - 3; c++) {\n    for (let r = 0; r < ROWS - 4; r++) {\n      let window = [\n        grid[r][c],\n        grid[r + 1][c + 1],\n        grid[r + 2][c + 2],\n        grid[r + 3][c + 3],\n      ];\n      score += evaluateWindow(window);\n    }\n  }\n\n  for (let c = 0; c < COLUMNS - 3; c++) {\n    for (let r = 3; r < ROWS - 1; r++) {\n      let window = [\n        grid[r][c],\n        grid[r - 1][c + 1],\n        grid[r - 2][c + 2],\n        grid[r - 3][c + 3],\n      ];\n      score += evaluateWindow(window);\n    }\n  }\n\n  return score;\n};\n\nconst evaluateWindow = (window) => {\n  let score = 0;\n  let ai_pieces = 0;\n  let player_pieces = 0;\n  let empty_pieces = 0;\n  for (let i = 0; i < window.length; i++) {\n    switch (window[i].piece) {\n      case AI:\n        ai_pieces++;\n        break;\n      case PLAYER:\n        player_pieces++;\n        break;\n      default:\n        empty_pieces++;\n    }\n  }\n  if (ai_pieces === 4) {\n    score += 100;\n  } else if (ai_pieces === 3 && empty_pieces === 1) {\n    score += 5;\n  } else if (ai_pieces === 2 && empty_pieces === 2) {\n    score += 2;\n  }\n\n  if (player_pieces === 3 && empty_pieces === 1) {\n    score -= 7;\n  } else if (player_pieces === 2 && empty_pieces === 2) {\n    score -= 5;\n  } else if (player_pieces === 2 && empty_pieces === 2) {\n    score -= 3;\n  }\n\n  return score;\n};\n\nconst getValidDrops = (grid) => {\n  let validRows = [];\n  for (let c = 0; c < COLUMNS; c++) {\n    if (grid[ROWS - 2][c].piece === 0) {\n      validRows.push(c);\n    }\n  }\n  return validRows;\n};\n\nconst isTerminalGrid = (grid) => {\n  let validDrops = getValidDrops(grid);\n  if (\n    checkForWin(grid, PLAYER) ||\n    checkForWin(grid, AI) ||\n    validDrops.length === 0\n  ) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nconst checkForWin = (grid, turn) => {\n  //check horizontal wins\n\n  for (let c = 0; c < COLUMNS - 3; c++) {\n    for (let r = 0; r < ROWS - 1; r++) {\n      if (\n        grid[r][c].piece === turn &&\n        grid[r][c + 1].piece === turn &&\n        grid[r][c + 2].piece === turn &&\n        grid[r][c + 3].piece === turn\n      ) {\n        return true;\n      }\n    }\n  }\n  //check vertical wins\n  for (let c = 0; c < COLUMNS; c++) {\n    for (let r = 0; r < ROWS - 4; r++) {\n      if (\n        grid[r][c].piece === turn &&\n        grid[r + 1][c].piece === turn &&\n        grid[r + 2][c].piece === turn &&\n        grid[r + 3][c].piece === turn\n      ) {\n        return true;\n      }\n    }\n  }\n  //check for upward diagonal wins\n  for (let c = 0; c < COLUMNS - 3; c++) {\n    for (let r = 0; r < ROWS - 4; r++) {\n      if (\n        grid[r][c].piece === turn &&\n        grid[r + 1][c + 1].piece === turn &&\n        grid[r + 2][c + 2].piece === turn &&\n        grid[r + 3][c + 3].piece === turn\n      ) {\n        return true;\n      }\n    }\n  }\n  //check for downward diagonal wins\n  for (let c = 0; c < COLUMNS - 3; c++) {\n    for (let r = 3; r < ROWS - 1; r++) {\n      if (\n        grid[r][c].piece === turn &&\n        grid[r - 1][c + 1].piece === turn &&\n        grid[r - 2][c + 2].piece === turn &&\n        grid[r - 3][c + 3].piece === turn\n      ) {\n        return true;\n      }\n    }\n  }\n};\n\nconst getNextOpenRow = (col, grid) => {\n  for (let row = 0; row < ROWS - 1; row++) {\n    if (grid[row][col].piece === 0) {\n      return row;\n    }\n  }\n  return Infinity;\n};\n\nconst getNewGrid = (row, col, grid, turn) => {\n  grid[row][col].piece = turn;\n  if (turn === PLAYER) {\n    grid[row][col].isPlayer = true;\n  } else {\n    grid[row][col].isAI = true;\n  }\n  grid[row][col].isEmpty = false;\n\n  return grid;\n};\n\nconst drawBoard = () => {\n  const grid = [];\n  for (let row = 0; row < ROWS; row++) {\n    const currentRow = [];\n    for (let col = 0; col < COLUMNS; col++) {\n      currentRow.push(createNode(col, row, 0));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row, piece) => {\n  return {\n    col,\n    row,\n    piece,\n    isEmpty: row !== ROWS - 1,\n    isPlayer: false,\n    isAI: false,\n    isSelector: row === ROWS - 1,\n  };\n};\n\nexport default Board;\n","import React from \"react\";\nimport Head from \"./components/head\";\nimport \"./App.css\";\nimport Board from \"./components/board\";\nimport \"bootstrap/dist/css/bootstrap.css\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Board></Board>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport \"bootstrap/dist/css/bootstrap.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}